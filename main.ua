# Experimental!
â”Œâ”€â•´PEâ‚
  Input â† 1000
  Call  â† /+ â–½âŠ¸(â†¥âˆ©=â‚€ âŠƒâ—¿â‚ƒâ—¿â‚…) â‡¡
â””â”€â•´
â”Œâ”€â•´PEâ‚‚
  Input â† 4e6
  Call  â† /+ â–½âŠ¸(=â‚€â—¿â‚‚) â†˜â‚‚[â¢âŠ™â—¡+<]âŠ™(1 1)
â””â”€â•´
â”Œâ”€â•´PEâ‚ƒ
  Input â† 600851475143
  Call  â† âŠ¡âŠ¸(â…Ã·â‚‚â§») +â‚âŠš?=â‚€Ëœâ—¿ âŸœ(+â‚â‡¡âŒˆâˆš)
â””â”€â•´
â”Œâ”€â•´PEâ‚„
  Input â† 3
  Call  â† /â†¥ â–½âŠ¸â‰¡(â‰âŠ¸â‡Œ Â°â‹•) â™­âŠÃ— . âœ-â‡¡ âˆ©(Ëœâ¿10) âŸœ-â‚
â””â”€â•´
â”Œâ”€â•´PEâ‚…
  Input  â† 20
  MaxExp â† âŠ“ËœÃ·â—Œ â¢(âŠ¸Ã—|>âŠƒâŠ™â‹…âŠ™).
  Call   â† /Ã— â‰¡âŒŸMaxExp â–½âŠ¸â‰¡(â‰âŠƒÂ°/Ã—Â¤) +1âŠ¸â‡¡
â””â”€â•´
â”Œâ”€â•´PEâ‚†
  Input â† 100
  Call  â† -âŠƒ(/+â¿â‚‚|â¿â‚‚/+) +â‚â‡¡
â””â”€â•´
â”Œâ”€â•´PEâ‚‡
  Input â† 10001
  # IsDivisible â† |2 >â‚€/+=âŠ¸â… Ã·
  # Call â† (
  #  âŠ¸[âˆ˜] 2
  #  â¢(â¨¬(âŠ¸âŠ‚|âˆ˜) â—¡IsDivisible âŠ™+â‚|>â§»âŠƒâŠ™â‹…âŠ™)
  #  â‹…âŠ™â—Œ
  # )
  Call â† âŠ“âŠ£â‹…â—Œ â¢(âŠƒâ¥âŠ‚â‹…â‹…+â‚‚ â—¡(=â‚€â§»âŠš=â‚€â—¿â¬šâˆâ†™âŒˆâ—¡â‹…âˆš)|>â§»âŠ™â‹…âŠ™) [2] 3
â””â”€â•´
â”Œâ”€â•´PEâ‚ˆ
  $ 73167176531330624919225119674426574742355349194934
  $ 96983520312774506326239578318016984801869478851843
  $ 85861560789112949495459501737958331952853208805511
  $ 12540698747158523863050715693290963295227443043557
  $ 66896648950445244523161731856403098711121722383113
  $ 62229893423380308135336276614282806444486645238749
  $ 30358907296290491560440772390713810515859307960866
  $ 70172427121883998797908792274921901699720888093776
  $ 65727333001053367881220235421809751254540594752243
  $ 52584907711670556013604839586446706324415722155397
  $ 53697817977846174064955149290862569321978468622482
  $ 83972241375657056057490261407972968652414535100474
  $ 82166370484403199890008895243450658541227588666881
  $ 16427171479924442928230863465674813919123162824586
  $ 17866458359124566529476545682848912883142607690042
  $ 24219022671055626321111109370544217506941658960408
  $ 07198403850962455444362981230987879927244284909188
  $ 84580156166097919133875499200524063689912560717606
  $ 05886116467109405077541002256983155200055935729725
  $ 71636269561882670428252483600823257530420752963450
  â–½âŠ¸â‰ @\n
  Data  â†
  Input â† 13
  Call  â† |1 /â†¥ â‰¡(/Ã— â‰¡â‚€â‹•) â§ˆâˆ˜ âŠ™Data
â””â”€â•´

â”Œâ”€â•´PEâ‚‰
  IsTriplet â† â†§â†§âŠƒ(=âŠ™+âˆ©â‚ƒâ¿â‚‚|â†§âŠƒ<â‹…<|â†§â†§âˆ©â‚ƒ(â‰âŠ¸â…)) Â°âŠŸâ‚ƒ
  Input     â†

  Call â† (
    1000
    â†¯âˆ_2 â‡¡ â†¯2

    â–½âŠ¸â‰¡(â†§âŠƒ(=â‚â‚€â‚€â‚€/+|IsTriplet) âŠŸâ‚ƒ â—¡âœâˆ©â¿â‚‚+ Â°âŠŸâ‚‚)
    Ã—Ã— â—¡âœâˆ©â¿â‚‚+ Â°âŠŸâ‚‚Â°Â¤
  )
  # This version works too but takes seven minutes to run:
  # Call â† (
  #  [0 1 2]
  #  âŠ¢path(
  #    â–½âŠ¸â‰¡(â†§âŠƒ>â‹…>Â°âŠŸâ‚ƒ) â‰+âŠ¸(âŠ=.â‡¡â§») # Neighs
  #  | â†§âŠƒ(=â‚â‚€â‚€â‚€/+|IsTriplet)    # Valid?
  #  )
  #  âŠ¸/Ã—âŠ£Â°â–¡
  # )
â””â”€â•´
â”Œâ”€â•´PEâ‚â‚€
  IsDivisible â† |2 >â‚€/+=âŠ¸â… Ã·

  Input â† 2e6
  Call â† (
    âŠ¸[âˆ˜] 2
    â¢(â¨¬(âŠ¸ËœâŠ‚|âˆ˜) â—¡IsDivisible âŠ™+â‚|>âŠ¢âŠƒâŠ™â‹…âŠ™)
    /+ âŠ“(â†˜â‚|â—Œ|â—Œ)
  )
â””â”€â•´

â”Œâ”€â•´PEâ‚â‚
  $ 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
  $ 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
  $ 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
  $ 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
  $ 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
  $ 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
  $ 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
  $ 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
  $ 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
  $ 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
  $ 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
  $ 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
  $ 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
  $ 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
  $ 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
  $ 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
  $ 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
  $ 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
  $ 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
  $ 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
  âŠœ(âŠœâ‹• âŠ¸â‰ @\s) âŠ¸â‰ @\n
  Input    â†
  SepDiags â† âŠ¸Â¬ â‡ŒâŠ> .â‡¡

  MainDiags â† (
    âŠ¸(â‡¡â§»)
    â‰¡âŒŸ(âŒâ¤¸0_0 â†»)
    SepDiagsâŠ¸â§»
    âˆ©âŒŸÃ—
  )
  MinorDiags â† âœâ‰¡â‡ŒMainDiags

  MaxProd â† /â†¥/â†¥â‰¡â§ˆâ¥â‚ƒÃ—

  Call â† (
    âŠƒ(MaxProd
    | MaxProdâ‰
    | â†¥âˆ©MaxProd MainDiags
    | â†¥âˆ©MaxProd MinorDiags
    )
    â†¥â†¥â†¥
  )
â””â”€â•´

â”Œâ”€â•´PEâ‚â‚‚
  DivisorsOf â† |1 â–½ âŠ¸(=âŠ¸â…Ã·) âŠ¸â‡¡
  Input      â†
  Call â† (
    â¢(âŠ™+â‚ âŠ¸+|>â§»DivisorsOf âŠ™â—Œ) 1 2 # T i divisorsWanted
  )
â””â”€â•´
â”Œâ”€â•´PEâ‚â‚„
  Input  â† 1e6
  Col    â† memo(â¨¬(+â‚Ã—â‚ƒ|Ã·â‚‚) =â‚€âŠ¸â—¿â‚‚)
  ColLen â† |1 memo(â¨¬(â¨¬(+â‚ ColLen +â‚Ã—â‚ƒ|+â‚ ColLenÃ·â‚‚) =â‚€âŠ¸â—¿â‚‚|1) âŠ¸=â‚)
  Call   â† +â‚Â°Â¤âŠšâŒ• âŠ¸/â†¥ â‰¡ColLen âœ-â‡¡ 1
â””â”€â•´
â”Œâ”€â•´PEâ‚â‚…
  Input â† 20
  Call  â† /â†¥ â¥(â§ˆ+ âœâ‡ŒâŠ‚â‚€âŠ‚â‚€) âŠ™[1] Ã—â‚‚ # Incrementally Pascal
â””â”€â•´
â”Œâ”€â•´PEâ‚â‚†
  Input â† 1000

  TrimZeros â† â–½Â¬âœâ‡Œ\â†§ âŠ¸=â‚€
  UpdCarry â† â¢(
    + âŠ“âŠ‚â‚€âœâ‡ŒâŠ‚â‚€ â‰¡âŠƒ(âŒŠÃ·â‚â‚€|â—¿â‚â‚€)
  | /â†¥>â‚â‚€
  )
  BigIntMul â† (
    â¬š0â‰¡UpdCarry âŠÃ—
    Ã—Ëœâ¿10âŠ¸(â‡¡â§»)
    /(UpdCarry â¬š0+) â¬š0â‰¡UpdCarry
    UpdCarry
    TrimZeros
  )
  Call â† /+ â¥(BigIntMul[2]) âŠ™[1]
  # Call â† /+/Fâ†¯ âŠ‚âŠ™(1 2)
  # Call  â† |1 /+ âˆµâ‹• Â°â‹• ğ„ˆâ¿2 # I have no idea how to do this one actually
â””â”€â•´
â”Œâ”€â•´PEâ‚â‚ˆ
  {[75]
   [95 64]
   [17 47 82]
   [18 35 87 10]
   [20 4 82 47 65]
   [19 1 23 75 3 34]
   [88 2 77 73 7 63 67]
   [99 65 4 28 6 16 70 92]
   [41 41 26 56 83 40 80 70 33]
   [41 48 72 33 47 32 37 16 94 29]
   [53 71 44 65 25 43 91 52 97 51 14]
   [70 11 33 28 77 73 17 78 39 68 17 57]
   [91 71 52 38 17 14 91 43 58 50 27 29 48]
   [63 66 4 68 89 53 67 30 73 16 69 87 40 31]
   [4 62 98 27 23 9 70 98 73 93 38 53 60 4 23]}
  Input â†
  Index â† ËœâŠ¡Â°â–¡âŠ¡âŠƒ(âŠ™â‹…âŠ™|â‹…âŠ™â‹…)
  MaxOf â† Â°â–¡/â†¥âš/â†¥
  # y x Data
  CostOf â† -âŠƒ(|Index|â‹…â‹…MaxOf)
  Call â† |1 (
    [0 0] # [y x] data
    âŠ¸(Â°â–¡âŠ¢path(
        âŠ™âŠ™â—Œ â—¡â‰¡âŒŸ(CostOfÂ°âŠŸ) [âœâŠ£+â‚.âœâŠ¢+â‚] # Neighbours and costs
      | â‰âŠ“(Â°Â¤â†™â‚|-â‚â§»)                  # Have we made it
      )
      âŠ™â—Œ)
    /+ â‰¡âŒŸIndex â‰¡Â°âŠŸ
  )
â””â”€â•´

â”Œâ”€â•´PEâ‚‚â‚€
  Input â† 100

  # TODO: This doesn't work. Where the hecc are we losing precision??
  Call â† /+ /(ËœPEâ‚â‚†~BigIntMul) â¬š0â‰¡âŠ¥â‚â‚€ +â‚â‡¡ 100

â””â”€â•´
â”Œâ”€â•´PEâ‚‚â‚‚
  Call â† (
    âŠœâ–¡âŠ¸â‰ @, &fras "./inputs/0022_names.txt"
    âš(/+ +â‚ -@Aâ†˜â‚‹â‚â†˜â‚) â†
    Â°â–¡/+âšÃ— âŠ¸(+â‚â‡¡â§»)
  )
â””â”€â•´
â”Œâ”€â•´PEâ‚‚â‚ƒ
  Ceiling    â† 28123
  IsAbundant â† < /+ â–½âŠ¸â‰¡(â‰âŠ¸â…) âŠ¸Ã· âŠ¸(+â‚âœ-â‚â‡¡)
  NotIn      â† â–½Â¬/â†¥âŠ¸âŠ=
  Call â† (
    # TODO: Make this not take 28m55s. Works though!
    âœ-â‡¡ 1 +â‚ Ceiling
    &p "getting abundant numbers"
    âŠ¸(â–½âŠ¸â‰¡IsAbundant) # All abundant numbers
    &p "found abundant numbers"
    âŠ¸/+ NotIn â™­âŠ+.
  )
â””â”€â•´
â”Œâ”€â•´PEâ‚‚â‚
  Input  â† 10000
  PD     â† /+â–½âŠ¸(=â‚€â—¿â‚)â†˜â‚Ã·+â‚âŠ¸â‡¡
  IsAmic â† Ã—âŠƒ(â‰PD|Â¬â‰)âŠ¸PD
  Call   â† /+â–½âŠ¸â‰¡IsAmic â‡¡Input
â””â”€â•´

â”Œâ”€â•´PEâ‚‚â‚„
  Input â† 10
  Call  â† /â—‡âŠ‚Â°â‹• âŠ¡-â‚ 1e6â§…â‰  : âŠ¸â‡¡
â””â”€â•´
â”Œâ”€â•´PEâ‚‚â‚ˆ
  Input â† 1001
  Next  â† +â‚ +âŠ¸âŠƒ(/â†¥/â†¥|â‡¡/â†¥â–³)
  Step  â† â¨¬(âœâŠ™â‰âŠ‚ â‡Œ|âŠ‚|âœâŠ™â‰ËœâŠ‚|ËœâŠ‚â‡Œ)
  Gen   â† +â‚ âˆ§(StepâŠ™Next) â—¿â‚„â‡¡+â‚ âŠ™[[0 1] [3 2]]
  Call â† (
    Gen -â‚…Ã—â‚‚        # spiral of of NxN => adding 2x-5 sides
    /++ âˆ©(âŒâ¤¸0_0) âŠ¸â‡Œ # Add up diagonals
    -â‚              # Remove dup'd center
  )
â””â”€â•´
â”Œâ”€â•´PEâ‚ƒâ‚€
  Input â† 5
  Call â† (
    âŠ¸(Ëœâ¿10 +1 âŒˆ Â°â‚‘â‚â‚€Ëœâ¿9) # Compute bound
    â†˜â‚‚â‡¡                  # All possible
    Ëœâ–½ âŸœâ‰¡âŒŸ(â‰âŸœ(/+Ëœâ¿âŠ¥â‚â‚€))  # Check
    /+                   # Add up
  )
â””â”€â•´

â”Œâ”€â•´PEâ‚†â‚‡
  Input â† âŠœ(â–¡âŠœâ‹• âŠ¸â‰ @\s) âŠ¸â‰ @\n &fras"./inputs/0067_triangle.txt"
  Call  â† PEâ‚â‚ˆ
â””â”€â•´

# Running area
